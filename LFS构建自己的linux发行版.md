> 人生第一次构建以失败告终

一个可用的`Linux发行`构成如下：
* 内核
* 库文件
* 可执行程序
* 配置文件

这些构成互依赖也很明显，`内核`为`库文件`提供底层接口，`库文件`为`可执行程序`提供各种函数方法，`配置文件`决定了`可执行程序`的运行方式。同样的反过来，`可执行程序`可以修改`配置文件`，`可执行程序`可以编译出`库文件`，而同样的`库文件`之间也有依赖关系，比如最底层的`库文件`往往是`libc`。

## Linux的启动流程(`grub`版本)
简单来说，一个`Linux`想最低限度的运行起来，我们看一下流程：
1. 加电后首先是`处理器`在`系统存储`中寻找到`BIOS`
2. `BIOS`检测系统资源后找引导设备，然后查找引导设备上的`主引导记录(MBR)`，把`MBR`加载入内存，控制权交接
3. `MBR`初始化引导程序`GRUB`
4. `grub`加载`kernel`
5. `kernel`按序查找到`init`程序执行，`kernel`挂起，控制权交接
6. `init`负责后面的各种事情。

相比于传统的`SysV init`，`Systemd`为了优化`init`的启动过程，引入的`并行启动`概念，极大的提高了速度，更不说还有其余的优点。

## 必须存在的东西
如果不想系统一直以`修复模式`启动的话，就至少得准备一个`init`。为了对系统做操作，那就还需要准备一个`shell`，需要能够拓展出新的功能，就必须要有`ToolChain`，而一个`ToolChain`需要包含的有`编译器`、`汇编器`、`链接器`、`库`和一些有用的`可执行程序`，`库`和`内核`间还需要相应的`API`提供一个编程接口。
那至少准备的东西有：
* `kernel` -- 内核
* `API` -- 编程接口
* `libc` -- c库
* `ld` -- 链接器
* `as` -- 汇编器
* `gcc` -- 编译器
* `init` -- init
* `bash` -- SHELL

## 交叉编译
构建发行版并不是直接构建的，而是在宿主机环境上先构建一个发行版`临时系统`，然后用`临时系统`构建最终的发行版，这样的目的就是为了让`最终发行版`和`宿主机`完全无关。
1. 宿主机编译出临时系统所用到的链接器(此刻ld程序是完全依赖于宿主机的)
2. 宿主机编译出临时系统用的编译器(此刻gcc程序是完全依赖于宿主机的)
3. 宿主机编译出临时系统用的API头文件
4. 用临时系统的gcc和ld编译链接出临时系统用的`libc`库文件
5. 宿主机编译临时系统的链接器，此时强制其使用临时系统的`libc`
6. 宿主机编译临时系统的编译器，强制其使用临时系统的`libc`

这六步之后，就已经做出了临时系统的`libc`，基于临时系统`libc`的`gcc`和`ld`，后面就用这些东西来编译最终发行版的程序，因为是为了保证可执行程序在对应平台上能执行。

## Linux文件目录树
这个按照标准来构造就行：[Filesystem Hierarchy Standard](http://www.pathname.com/fhs/pub/fhs-2.3.html)

为了让 root 用户能正常登录，而且「root」的名字能被正常识别，必须在文件 /etc/passwd 和 /etc/group 中写入相应的内容。

## 构建最终发行版工具链
用`临时系统`的工具把最终发行版的`glibc`和`API`都构建好，就可以把`最终发行版`的`toolchain`做出来了。然后按照正常的流程构建就行。

# 参考资料
* [Linux From Scratch （简体中文版）](https://lctt.github.io/LFS-BOOK/lfs-systemd/LFS-SYSD-BOOK.html#chapter-bootable)
* [lfs方法及原理](http://blog.chinaunix.net/uid-20761674-id-3799855.html)
* [gcc fails to build with isl>=0.20](https://trac.sagemath.org/ticket/26735)
* [走进Linux之systemd启动过程](https://www.cnblogs.com/swordxia/p/4521428.html)